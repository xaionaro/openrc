Description: This patch adds support for the sysv-rc LSB headers
Author: heroxbd <heroxbd@gentoo.org>
Origin: upstream

--- openrc-0.12.orig/scripts/Makefile
+++ openrc-0.12/scripts/Makefile
@@ -1,5 +1,5 @@
 DIR=	${LIBEXECDIR}/bin
-BIN=	on_ac_power
+BIN=	on_ac_power lsb.pl
 
 MK=	../mk
 include ${MK}/scripts.mk
--- /dev/null
+++ openrc-0.12/scripts/lsb.pl
@@ -0,0 +1,122 @@
+#!/usr/bin/perl
+# parse lsb header and print as in OpenRC style.
+# base code borrowed from update-rc.d of Debian
+
+use Switch;
+use File::Basename;
+
+my $initdscript = shift;
+my $name = basename($initdscript);
+my %lsb2orc = ('$all' => '*');
+
+my %vsrv;
+open(VSERV, "</etc/insserv.conf") || die "error: unable to read /etc/insserv.conf";
+while (<VSERV>){
+    next if (m/^\#.*/);
+    chomp;
+    if (m/^(\$\w+)\s*(\S?.*)$/i) {
+	my $vs=$1;
+	foreach $srv (split(/ /,$2)) {
+	    if ($srv =~ m/\+(\S?.*)/i) {
+		$vsrv{$1} = $vs;
+	    }
+	}
+    }
+}
+
+my %lsbinfo;
+my $lsbheaders = "Provides|Required-Start|Required-Stop|Default-Start|Default-Stop|Short-Description|Description|Should-Start|Should-Stop|X-Start-Before|X-Start-After";
+open(INIT, "<$initdscript") || die "error: unable to read $initdscript";
+while (<INIT>) {
+    chomp;
+    $lsbinfo{'found'} = 1 if (m/^\#\#\# BEGIN INIT INFO\s*$/);
+    last if (m/\#\#\# END INIT INFO\s*$/);
+    if (m/^\# ($lsbheaders):\s*(\S?.*)$/i) {
+	$lsbinfo{lc($1)} = $2;
+    }
+}
+close(INIT);
+
+my $dep='';
+my $des='';
+
+sub l2of {
+    my @value;
+    my $items = shift;
+    foreach $v (split(/ /, $items)) {
+	if($lsb2orc{$v}){
+	    $v=$lsb2orc{$v}
+	}
+	push(@value,$v)
+    }
+    return join(" ", @value)
+}
+
+#Bug 714039
+my $ifall = 0;
+
+sub isall {
+	my $ret = shift;
+	my @rets;
+	foreach $t (split(/ /, $ret)) {
+		if("*" eq $t){
+			$ifall = 1;
+		}else{
+			push(@rets,$t);
+		}
+	}
+	return join(" ", @rets);
+}
+#end
+
+# Check that all the required headers are present
+if ($lsbinfo{found}) {
+    foreach $key (keys %lsbinfo) {
+	switch ($key) {
+	    case "provides" {
+		my @value;
+		foreach $v (split(/ /, $lsbinfo{$key})) {
+		    push(@value, $lsb2orc{$vsrv{$v}}) if($vsrv{$v});
+		    push(@value, $lsb2orc{$v}) if ($v);
+		    push(@value, $v) if ($v ne $name);
+		}
+		if (@value) {
+		    $dep .= "\tprovide " . join(" ", @value) . "\n";
+		}
+	    }
+	    case "required-start" {
+		my $ret = l2of $lsbinfo{$key};
+		if($ret) {
+			#This code will no longer need when the bug be resolved.
+			#Bug 714039
+			my $rets = isall($ret);
+			if($ifall){
+				$dep .= "\tneed " . $rets . "\n";
+				$dep .= "\tuse " . "*" . "\n";
+			}else{$dep .= "\tneed " . $ret . "\n"}
+		}
+	    }
+	    case "required-stop" {}
+	    case "default-start" {}
+	    case "default-stop" {}
+	    case "short-description" {
+		$des .= 'description="'.$lsbinfo{$key}.'"'."\n";
+	    }
+	    case "description" {}
+	    case "should-start" {
+		my $ret = l2of $lsbinfo{$key};
+		if ($ret) {$dep .= "\tuse " . $ret . "\n"}
+	    }
+	    case "should-stop" {}
+	    case "x-start-before" {
+		my $ret = l2of $lsbinfo{$key};
+		if ($ret) {$dep .= "\tbefore " . $ret . "\n"}
+	    }
+	    case "x-stop-after" {}
+	}
+    }
+}
+if ($dep) {$rst = "depend () {\n" . $dep . "}\n"};
+if ($des) {$rst = $des . "\n" . $rst};
+
+print $rst
--- openrc-0.12.orig/sh/gendepends.sh.in
+++ openrc-0.12/sh/gendepends.sh.in
@@ -81,10 +81,14 @@
 
 		[ -e @SYSCONFDIR@/rc.conf ] && . @SYSCONFDIR@/rc.conf
 
-		if . "$_dir/$RC_SVCNAME"; then
-			echo "$RC_SVCNAME" >&3
-			_depend
+		lsbh=$(lsb.pl "$RC_SERVICE")
+		if [ -n "${lsbh}" ]; then
+			eval "${lsbh}"
+		else
+			. "$_dir/$RC_SVCNAME"
 		fi
+		echo "$RC_SVCNAME" >&3
+		_depend
 		)
 	done
 done
--- openrc-0.12.orig/sh/runscript.sh.in
+++ openrc-0.12/sh/runscript.sh.in
@@ -217,28 +217,33 @@
 	cgroup_set_limits
 
 # Load our script
-sourcex "$RC_SERVICE"
-
-for _d in $required_dirs; do
-	if [ ! -d $_d ]; then
-		eerror "$RC_SVCNAME: \`$_d' is not a directory"
-		exit 1
-	fi
-done
-unset _d
-
-for _f in $required_files; do
-	if [ ! -r $_f ]; then
-		eerror "$RC_SVCNAME: \`$_f' is not readable"
-		exit 1
+lsbh=$(lsb.pl "$RC_SERVICE")
+if [ -n "${lsbh}" ]; then
+	eval "${lsbh}"
+else
+	sourcex "$RC_SERVICE"
+
+	for _d in $required_dirs; do
+		if [ ! -d $_d ]; then
+			eerror "$RC_SVCNAME: \`$_d' is not a directory"
+			exit 1
+		fi
+	done
+	unset _d
+
+	for _f in $required_files; do
+		if [ ! -r $_f ]; then
+			eerror "$RC_SVCNAME: \`$_f' is not readable"
+			exit 1
+		fi
+	done
+	unset _f
+
+	if [ -n "$opts" ]; then
+			ewarn "Use of the opts variable is deprecated and will be"
+			ewarn "removed in the future."
+			ewarn "Please use extra_commands, extra_started_commands or extra_stopped_commands."
 	fi
-done
-unset _f
-
-if [ -n "$opts" ]; then
-		ewarn "Use of the opts variable is deprecated and will be"
-		ewarn "removed in the future."
-		ewarn "Please use extra_commands, extra_started_commands or extra_stopped_commands."
 fi
 
 while [ -n "$1" ]; do
@@ -252,7 +257,12 @@
 		_depend
 		cd /
 		continue
+	elif [ -n "${lsbh}" ]; then
+		. "${RC_SERVICE}"
+		shift
+		continue
 	fi
+
 	# See if we have the required function and run it
 	for _cmd in describe start stop status ${extra_commands:-$opts} \
 		$extra_started_commands $extra_stopped_commands
--- openrc-0.12.orig/src/librc/librc.c
+++ openrc-0.12/src/librc/librc.c
@@ -91,13 +91,6 @@
 				r = stat(file, &buf);
 				if (r != 0)
 					continue;
-
-				/* .sh files are not init scripts */
-				l = strlen(d->d_name);
-				if (l > 2 && d->d_name[l - 3] == '.' &&
-				    d->d_name[l - 2] == 's' &&
-				    d->d_name[l - 1] == 'h')
-					continue;
 			}
 			if (options & LS_DIR) {
 				if (stat(d->d_name, &buf) == 0 &&
@@ -509,16 +502,6 @@
 		errno = EINVAL;
 		return false;
 	}
-
-	len = strlen(service);
-
-	/* .sh files are not init scripts */
-	if (len > 2 && service[len - 3] == '.' &&
-	    service[len - 2] == 's' &&
-	    service[len - 1] == 'h') {
-		errno = EINVAL;
-		return false;
-	}
 
 	if (!(file = rc_service_resolve(service))) {
 		errno = ENOENT;
--- openrc-0.12.orig/src/rc/rc-misc.c
+++ openrc-0.12/src/rc/rc-misc.c
@@ -255,12 +255,13 @@
 pid_t
 exec_service(const char *service, const char *arg)
 {
-	char *file, sfd[32];
+	char *file, sfd[32], bsvc[32];
 	int fd;
 	pid_t pid = -1;
 	sigset_t full;
 	sigset_t old;
 	struct sigaction sa;
+	FILE *fsvc;
 
 	fd = svc_lock(basename_c(service));
 	if (fd == -1)
@@ -295,10 +296,17 @@
 		/* Unmask signals */
 		sigprocmask(SIG_SETMASK, &old, NULL);
 
-		/* Safe to run now */
-		execl(file, file, "--lockfd", sfd, arg, (char *) NULL);
-		fprintf(stderr, "unable to exec `%s': %s\n",
-		    file, strerror(errno));
+		/* Safe to run now, to support scripts without runscript shebang
+		   we need to make a check first. */
+		fsvc = fopen(file,"r");
+		fgets(bsvc, sizeof(bsvc), fsvc);
+		if (strstr(bsvc, "runscript")) {
+			execl(file, file, "--lockfd", sfd, arg, (char *) NULL);
+			fprintf(stderr, "unable to exec `%s': %s\n",
+			    file, strerror(errno));
+		} else {
+			execl(file, file, arg, (char *) NULL);
+		}
 		svc_unlock(basename_c(service), fd);
 		_exit(EXIT_FAILURE);
 	}
